{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to justin.albrethseng.com My name is Justin Albrethsen and this is my personal site that I use to document and share my projects, publications, and a little about myself. About me Right now I am living in Singapore with my wife Ruixin and our son Shane and we are getting ready to move back to my old home in Pittsburgh near the end of this year. While I generally enjoy working with my hands and building thing, living in a very dense city with high cost of land puts those interests out of reach for the moment. This has steered my interests towards more space constrained activities like building software or computers. For work I am doing research at Singapore University of Technology & Design. I worked there for nearly 5 years now on a few different projects. I started off building deep learning models to detect cyber attacks in power grids, then when that project finished I moved on to analyzing sensor data and forecasting residential power/water usage. After that I moved to building AI models to manage tactical networks and building the tools to let the AI models interact with the simulated networks. Finally my current project involves bringing software defined networks (SDN) to tactical networks for rapid network configuration of large scale military networks. One of the things that I most enjoy about research is the ability to move to new projects that sound interesting and then spend time learning about a new domain before applying what I have learned. I also get to have a diversity of roles within my role. I manage our server infrastructure, I write papers that get published, I build tools to run simulations, tools to process the simulation data, and AI models to learn from it all. In a previous life I was a fresh mechanical engineering grad working in a paint factory. There I got to manage capital projects, design industrial automation systems, implement efficiency improvements, and troubleshoot some very interesting machinary. Here I learned my way around a PLC control cabinet (do NOT put your power cables in the same track as your sensor cables), and that almost every problem is due to dust on your sensors. Over the course of my futile pursuit to learn how everything works, I have completed a few personal projects here and there and have documented them on this site. Why albrethseng.com? Those of you who are very sharp may notice that although my last name is Albrethsen, I use the domain albrethseng.com. This is because I originally used the domain to serve a registration page for my wedding. Since it is a wedding I thought it fitting that the domain include both mine and my wife's last names (hers is Ng) which fit in neatly at the end of mine, hence AlbrethseNg.","title":"Home"},{"location":"#welcome-to-justinalbrethsengcom","text":"My name is Justin Albrethsen and this is my personal site that I use to document and share my projects, publications, and a little about myself.","title":"Welcome to justin.albrethseng.com"},{"location":"#about-me","text":"Right now I am living in Singapore with my wife Ruixin and our son Shane and we are getting ready to move back to my old home in Pittsburgh near the end of this year. While I generally enjoy working with my hands and building thing, living in a very dense city with high cost of land puts those interests out of reach for the moment. This has steered my interests towards more space constrained activities like building software or computers. For work I am doing research at Singapore University of Technology & Design. I worked there for nearly 5 years now on a few different projects. I started off building deep learning models to detect cyber attacks in power grids, then when that project finished I moved on to analyzing sensor data and forecasting residential power/water usage. After that I moved to building AI models to manage tactical networks and building the tools to let the AI models interact with the simulated networks. Finally my current project involves bringing software defined networks (SDN) to tactical networks for rapid network configuration of large scale military networks. One of the things that I most enjoy about research is the ability to move to new projects that sound interesting and then spend time learning about a new domain before applying what I have learned. I also get to have a diversity of roles within my role. I manage our server infrastructure, I write papers that get published, I build tools to run simulations, tools to process the simulation data, and AI models to learn from it all. In a previous life I was a fresh mechanical engineering grad working in a paint factory. There I got to manage capital projects, design industrial automation systems, implement efficiency improvements, and troubleshoot some very interesting machinary. Here I learned my way around a PLC control cabinet (do NOT put your power cables in the same track as your sensor cables), and that almost every problem is due to dust on your sensors. Over the course of my futile pursuit to learn how everything works, I have completed a few personal projects here and there and have documented them on this site.","title":"About me"},{"location":"#why-albrethsengcom","text":"Those of you who are very sharp may notice that although my last name is Albrethsen, I use the domain albrethseng.com. This is because I originally used the domain to serve a registration page for my wedding. Since it is a wedding I thought it fitting that the domain include both mine and my wife's last names (hers is Ng) which fit in neatly at the end of mine, hence AlbrethseNg.","title":"Why albrethseng.com?"},{"location":"FPGA%20Tang%20Nano%209K/","text":"Open IDE /home/justin/packages/gowin_ide/IDE/bin/gw_ide Flash picotiny example sudo ~/packages/openFPGALoader/build/openFPGALoader -b tangnano9k -f ~/packages/gowin_ide/TangNano-9K-example/picotiny/picotiny.fs screen /dev/ttyUSB1 115200 Future idea Make something like the esp32 turnkey modules so this can be easily integrated into other IC designs.","title":"FPGA"},{"location":"FPGA%20Tang%20Nano%209K/#open-ide","text":"/home/justin/packages/gowin_ide/IDE/bin/gw_ide","title":"Open IDE"},{"location":"FPGA%20Tang%20Nano%209K/#flash-picotiny-example","text":"sudo ~/packages/openFPGALoader/build/openFPGALoader -b tangnano9k -f ~/packages/gowin_ide/TangNano-9K-example/picotiny/picotiny.fs screen /dev/ttyUSB1 115200","title":"Flash picotiny example"},{"location":"FPGA%20Tang%20Nano%209K/#future-idea","text":"Make something like the esp32 turnkey modules so this can be easily integrated into other IC designs.","title":"Future idea"},{"location":"Linux%20commands/","text":"View process tree ps -ef --forest See which process is editing a file lsof <filename> View cpu core utilization in realtime mpstat -P ALL 2","title":"Linux Commands"},{"location":"Linux%20commands/#view-process-tree","text":"ps -ef --forest","title":"View process tree"},{"location":"Linux%20commands/#see-which-process-is-editing-a-file","text":"lsof <filename>","title":"See which process is editing a file"},{"location":"Linux%20commands/#view-cpu-core-utilization-in-realtime","text":"mpstat -P ALL 2","title":"View cpu core utilization in realtime"},{"location":"Linux%20tunnels/","text":"VXLAN used in proxmox to have all VM's appear on same layer 2 network Commands to run on Linux sudo ip link add vxlan-1 type vxlan id 100 dev butler dstport 4789 sudo ip addr add 192.168.210.2/24 dev vxlan-1 sudo bridge fdb append to 00:00:00:00:00:00 dst 10.200.100.1 dev vxlan-1 sudo bridge fdb append to 00:00:00:00:00:00 dst 10.200.100.8 dev vxlan-1 sudo ip link set vxlan-1 up Geneve intended to replace proliferation of linux tunnels including vxlan and gre uses udp encapsulation Commands to run on Linux sudo ip link add gen0 type geneve id 12345 remote 192.168.50.158 tos 48 sudo ip addr add 192.168.4.2/24 dev gen0 sudo ip link set gen0 up","title":"Linux Tunnels"},{"location":"Linux%20tunnels/#vxlan","text":"used in proxmox to have all VM's appear on same layer 2 network","title":"VXLAN"},{"location":"Linux%20tunnels/#commands-to-run-on-linux","text":"sudo ip link add vxlan-1 type vxlan id 100 dev butler dstport 4789 sudo ip addr add 192.168.210.2/24 dev vxlan-1 sudo bridge fdb append to 00:00:00:00:00:00 dst 10.200.100.1 dev vxlan-1 sudo bridge fdb append to 00:00:00:00:00:00 dst 10.200.100.8 dev vxlan-1 sudo ip link set vxlan-1 up","title":"Commands to run on Linux"},{"location":"Linux%20tunnels/#geneve","text":"intended to replace proliferation of linux tunnels including vxlan and gre uses udp encapsulation","title":"Geneve"},{"location":"Linux%20tunnels/#commands-to-run-on-linux_1","text":"sudo ip link add gen0 type geneve id 12345 remote 192.168.50.158 tos 48 sudo ip addr add 192.168.4.2/24 dev gen0 sudo ip link set gen0 up","title":"Commands to run on Linux"},{"location":"Minimal%20Linux/","text":"Objective My goal with this project is to see how small I can make a functional system, it can be useful on storage constrained embedded devices to create a OS with only the tools needed to do a job and nothing more. This is an attempt to create a base template for such a system and also to further my understanding of computers and Linux. Install dependencies Install standard build tools using apt, zypper, pacman, etc.. (gcc, bison, flex, git, etc..) Build Linux Clone latest stable release of linux kernel git clone --depth=1 --branch=v6.13 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git Make the minimal config included with linux, this config is included by default but it is not quite usable make tinyconfig Then you have the tiniest possible kernel, to make it usable add a few key items. make menuconfig 64-bit kernel General setup/Initial RAM filesystem and RAM disk (initramfs/initrd) support General setup/Configure standard kernel features (expert users)/Enable support for printk Executable file formats/kernel support for elf binaries Executable file formats/kernel support for scripts starting with #! Device drivers/Character devices/Enable TTY File systems/Pseudo filesystems/proc support File systems/Pseudo filesystems/sysfs support Power management and ACPI options / ACPI support Processor type and features / EFI runtime service support Processor type and features / EFI runtime service support / EFI stub support Device drivers / Graphics support / Framebuffer devices / Support for frame buffer device drivers Device drivers / Graphics support / Framebuffer devices / Support for frame buffer device drivers / EFI-based Framebuffer Support Device drivers / Graphics support / Console display driver support / Framebuffer Console support Save the config and then compile the kernel make -j 6 Build busybox Busybox is a good tool for simplifying the setup of our embedded system as it includes all your tools in a single binary. wget https://busybox.net/downloads/busybox-1.37.0.tar.bz2 tar -xvjf busybox-1.37.0.tar.bz2 cd busybox-1.37.0/ Now we make the config, here you can choose what tools to package within busybox make menuconfig Enable Settings/Build static binary (no shared libs) make -j 6 Build initrd we create a directory to store our init scripts and copy our busybox mkdir ~/initramfs mkdir ~/initramfs/bin cp busybox ~/initramfs/bin/ Next we create an init script in \\~/initramfs/bin/init #!/bin/busybox sh /bin/busybox mkdir -p /usr/bin /bin/busybox mkdir -p /usr/sbin /bin/busybox mkdir /sbin /bin/busybox mkdir /proc /bin/busybox mkdir /sys /bin/busybox mount -t sysfs none /sys /bin/busybox mount -t proc none /proc /bin/busybox --install -s exec /bin/sh Then make it executable chmod +x ~/initramfs/bin/init Now we go to the directory and turn it into an initrd cd ~/initramfs find . -print0 | cpio --null --create --verbose --format=newc | gzip --best > ../initrd Now we have initrd file in \\~/initrd You can boot this initrd and kernel with qemu to get a shell qemu-system-x86_64 -kernel arch/x86/boot/bzImage -initrd ~/initrd You should now be greeted with a simple shell that you can interact with your minimal linux system Make bootable USB sudo fdisk /dev/sdb Create new partition and set type to EFI System create fat32 filesystem sudo mkfs.fat -F 32 /dev/sdb1 mount /dev/sdb1 /mnt/hda cp ~/initrd /mnt/hda cp ~linux/arch/x86/boot/bzImage /mnt/hda create startup script startup.nsh fs0:\\bzImage initrd=initrd Then copy the startup.nsh to the root of your usb stick cp startup.nsh /mnt/hda Plugin and bootup your minimal linux on real hardware. You may need to navigate the efi shell if this startup.nsh does not get called correctly.","title":"Tiny Linux"},{"location":"Minimal%20Linux/#objective","text":"My goal with this project is to see how small I can make a functional system, it can be useful on storage constrained embedded devices to create a OS with only the tools needed to do a job and nothing more. This is an attempt to create a base template for such a system and also to further my understanding of computers and Linux.","title":"Objective"},{"location":"Minimal%20Linux/#install-dependencies","text":"Install standard build tools using apt, zypper, pacman, etc.. (gcc, bison, flex, git, etc..)","title":"Install dependencies"},{"location":"Minimal%20Linux/#build-linux","text":"Clone latest stable release of linux kernel git clone --depth=1 --branch=v6.13 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git Make the minimal config included with linux, this config is included by default but it is not quite usable make tinyconfig Then you have the tiniest possible kernel, to make it usable add a few key items. make menuconfig 64-bit kernel General setup/Initial RAM filesystem and RAM disk (initramfs/initrd) support General setup/Configure standard kernel features (expert users)/Enable support for printk Executable file formats/kernel support for elf binaries Executable file formats/kernel support for scripts starting with #! Device drivers/Character devices/Enable TTY File systems/Pseudo filesystems/proc support File systems/Pseudo filesystems/sysfs support Power management and ACPI options / ACPI support Processor type and features / EFI runtime service support Processor type and features / EFI runtime service support / EFI stub support Device drivers / Graphics support / Framebuffer devices / Support for frame buffer device drivers Device drivers / Graphics support / Framebuffer devices / Support for frame buffer device drivers / EFI-based Framebuffer Support Device drivers / Graphics support / Console display driver support / Framebuffer Console support Save the config and then compile the kernel make -j 6","title":"Build Linux"},{"location":"Minimal%20Linux/#build-busybox","text":"Busybox is a good tool for simplifying the setup of our embedded system as it includes all your tools in a single binary. wget https://busybox.net/downloads/busybox-1.37.0.tar.bz2 tar -xvjf busybox-1.37.0.tar.bz2 cd busybox-1.37.0/ Now we make the config, here you can choose what tools to package within busybox make menuconfig Enable Settings/Build static binary (no shared libs) make -j 6","title":"Build busybox"},{"location":"Minimal%20Linux/#build-initrd","text":"we create a directory to store our init scripts and copy our busybox mkdir ~/initramfs mkdir ~/initramfs/bin cp busybox ~/initramfs/bin/ Next we create an init script in \\~/initramfs/bin/init #!/bin/busybox sh /bin/busybox mkdir -p /usr/bin /bin/busybox mkdir -p /usr/sbin /bin/busybox mkdir /sbin /bin/busybox mkdir /proc /bin/busybox mkdir /sys /bin/busybox mount -t sysfs none /sys /bin/busybox mount -t proc none /proc /bin/busybox --install -s exec /bin/sh Then make it executable chmod +x ~/initramfs/bin/init Now we go to the directory and turn it into an initrd cd ~/initramfs find . -print0 | cpio --null --create --verbose --format=newc | gzip --best > ../initrd Now we have initrd file in \\~/initrd You can boot this initrd and kernel with qemu to get a shell qemu-system-x86_64 -kernel arch/x86/boot/bzImage -initrd ~/initrd You should now be greeted with a simple shell that you can interact with your minimal linux system","title":"Build initrd"},{"location":"Minimal%20Linux/#make-bootable-usb","text":"sudo fdisk /dev/sdb Create new partition and set type to EFI System create fat32 filesystem sudo mkfs.fat -F 32 /dev/sdb1 mount /dev/sdb1 /mnt/hda cp ~/initrd /mnt/hda cp ~linux/arch/x86/boot/bzImage /mnt/hda create startup script startup.nsh fs0:\\bzImage initrd=initrd Then copy the startup.nsh to the root of your usb stick cp startup.nsh /mnt/hda Plugin and bootup your minimal linux on real hardware. You may need to navigate the efi shell if this startup.nsh does not get called correctly.","title":"Make bootable USB"},{"location":"Proxmox%20Resize%20Disk/","text":"sudo fdisk /dev/sda delete partition to resize (/dev/sda2) recreate partition and redefine the end of partition do not delete ext4 signature (not sure if it makes a difference) write to disk sudo resize2fs /dev/sda2","title":"Proxmox Resize Disk"},{"location":"Proxmox%20import%20parrot%20.ova/","text":"Download VM as .ova format tar -xvf .ova qm importovf ex. qm importovf 122 Parrot-security-6.3.2_amd64.ovf vol_vms import disk qm importdisk 122 Parrot-security-6.3.2_amd64-disk001.vmdk vol_vms change settings to q35, virtio scsi, ovmf user: user pass: parrot","title":"Proxmox Import ova"},{"location":"SSH/","text":"tips and tricks for using ssh Config file \\~/.ssh/config Host host1 HostName 192.168.1.2 IdentityFile \\~/.ssh/home_id_rsa Port 8022 User justin KexAlgorithms +diffie-hellman-group1-sha1 Host host2 HostName 192.168.5.2 ProxyJump host1 Port 18022 User justin LocalForward 9443 192.168.5.3:9443 LocalForward 8888 localhost:8888 CLI forward port to local ssh host1 -L 8889: localhost:8889 Run shell commands and return output ssh host1 whoami Now fork the command to background ssh -f host1 whoami","title":"SSH Commands"},{"location":"SSH/#config-file-sshconfig","text":"Host host1 HostName 192.168.1.2 IdentityFile \\~/.ssh/home_id_rsa Port 8022 User justin KexAlgorithms +diffie-hellman-group1-sha1 Host host2 HostName 192.168.5.2 ProxyJump host1 Port 18022 User justin LocalForward 9443 192.168.5.3:9443 LocalForward 8888 localhost:8888","title":"Config file \\~/.ssh/config"},{"location":"SSH/#cli","text":"","title":"CLI"},{"location":"SSH/#forward-port-to-local","text":"ssh host1 -L 8889: localhost:8889","title":"forward port to local"},{"location":"SSH/#run-shell-commands-and-return-output","text":"ssh host1 whoami","title":"Run shell commands and return output"},{"location":"SSH/#now-fork-the-command-to-background","text":"ssh -f host1 whoami","title":"Now fork the command to background"},{"location":"SSH/#_1","text":"","title":""},{"location":"Ubuntu%20thin%20client/","text":"Setup nfsroot loosely based on https://help.ubuntu.com/community/DisklessUbuntuHowto Install requirements sudo apt install nfs-kernel-server -y sudo systemctl enable --now nfs-kernel-server.service Make directory and add it to exports file sudo mkdir /nfsroot sudo vim /etc/exports /nfsroot 192.168.205.0/24(rw,no_root_squash,async,insecure) Sync the nfs exports sudo exportfs -rv Enter working system (client) with fresh install sudo cp /boot/vmlinuz-`uname -r` ~ sudo vim /etc/initramfs-tools/initramfs.conf BOOT=nfs MODULES=netboot mkinitramfs -o ~/initrd.img-`uname -r` Mount nfsroot on working system (client) sudo apt install -y nfs-common mount -t nfs -onolock 192.168.205.10:/nfsroot /mnt cp -ax /. /mnt/. cp -ax /dev/. /mnt/dev/. Setup pxe boot and tftp Install requirements sudo apt-get install isc-dhcp-server tftpd-hpa syslinux pxelinux initramfs-tools Setup dhcp server /etc/dhcp/dhcpd.conf allow booting; allow bootp; subnet 192.168.2.0 netmask 255.255.255.0 { range 192.168.2.xxx 192.168.2.xxx; option broadcast-address 192.168.2.255; option routers 192.168.2.xxx; option domain-name-servers 192.168.2.xxx; filename \"pxelinux.0\"; next-server 192.168.3.10; } # force the client to this ip for pxe. # This is only necessary assuming you want to send different images to different computers. host pxe_client { hardware ethernet xx:xx:xx:xx:xx:xx; fixed-address 192.168.2.xxx; } Set DHCP server interface (must be in the correct dhcp range) #/etc/default/isc-dhcp-server INTERFACESv4=ens18 Restart DHCP Server using the command sudo service isc-dhcp-server restart On mine I had vyos point to my tftp server and nfsroot configure set service dhcp-server shared-network-name 'vxlan' subnet 192.168.205.0/24 option bootfile-name pxelinux.0 set service dhcp-server shared-network-name 'vxlan' subnet 192.168.205.0/24 option bootfile-server 192.168.205.10 commit save Configure tftpd # /etc/default/tftpd-hpa RUN_DAEMON=\"yes\" TFTP_ADDRESS=\"0.0.0.0:69\" TFTP_USERNAME=\"tftp\" TFTP_DIRECTORY=\"/tftpboot\" TFTP_OPTIONS=\"-l -s\" Copy files from server (may also work with client fresh install) sudo mkdir -p /tftpboot/pxelinux.cfg sudo mkdir -p /tftpboot/boot sudo cp /usr/lib/PXELINUX/pxelinux.0 /tftpboot sudo cp -r /usr/lib/syslinux/modules/bios /tftpboot/boot/isolinux Create /tftpboot/pxelinux.cfg/default LABEL linux DEFAULT linux KERNEL vmlinuz-5.4.0-195-generic APPEND root=/dev/nfs initrd=initrd.img-5.4.0-195-generic nfsroot=192.168.205.10:/nfsroot ip=dhcp rw console=tty0 console=ttyS0,115200n8 Get tftp started sudo chmod -R 777 /tftpboot sudo /etc/init.d/tftpd-hpa start Put it all together Add kernel and initrd to tftpboot folder from the fresh install copied to nfsroot sudo cp /nfsroot/home/ubuntu/vmlinuz-5.4.0-195-generic /tftpboot/ sudo cp /nfsroot/home/ubuntu/initrd.img-5.4.0-195-generic /tftpboot/ Configure /nfsroot/etc/fstab, this is important to avoid parallel clients locking each other out none /var/run tmpfs defaults 0 0 none /var/log tmpfs defaults 0 0 none /var/lock tmpfs defaults 0 0 none /var/tmp tmpfs defaults 0 0 proc /proc proc defaults 0 0 none /media tmpfs defaults 0 0 none /var/lib/dhcp tmpfs defaults 0 0 none /tmp tmpfs defaults 0 0 Comment out exec update-grub in /nfsroot/etc/kernel/postinst.d/zz-update-grub Clear out entries from client netplan to avoid messing with interface, it already has dhcp setup may have to disable ipv6 if issues bringing up iface","title":"Thin Client"},{"location":"Ubuntu%20thin%20client/#setup-nfsroot","text":"loosely based on https://help.ubuntu.com/community/DisklessUbuntuHowto","title":"Setup nfsroot"},{"location":"Ubuntu%20thin%20client/#install-requirements","text":"sudo apt install nfs-kernel-server -y sudo systemctl enable --now nfs-kernel-server.service","title":"Install requirements"},{"location":"Ubuntu%20thin%20client/#make-directory-and-add-it-to-exports-file","text":"sudo mkdir /nfsroot sudo vim /etc/exports /nfsroot 192.168.205.0/24(rw,no_root_squash,async,insecure)","title":"Make directory and add it to exports file"},{"location":"Ubuntu%20thin%20client/#sync-the-nfs-exports","text":"sudo exportfs -rv","title":"Sync the nfs exports"},{"location":"Ubuntu%20thin%20client/#enter-working-system-client-with-fresh-install","text":"sudo cp /boot/vmlinuz-`uname -r` ~ sudo vim /etc/initramfs-tools/initramfs.conf BOOT=nfs MODULES=netboot mkinitramfs -o ~/initrd.img-`uname -r`","title":"Enter working system (client) with fresh install"},{"location":"Ubuntu%20thin%20client/#mount-nfsroot-on-working-system-client","text":"sudo apt install -y nfs-common mount -t nfs -onolock 192.168.205.10:/nfsroot /mnt cp -ax /. /mnt/. cp -ax /dev/. /mnt/dev/.","title":"Mount nfsroot on working system (client)"},{"location":"Ubuntu%20thin%20client/#setup-pxe-boot-and-tftp","text":"","title":"Setup pxe boot and tftp"},{"location":"Ubuntu%20thin%20client/#install-requirements_1","text":"sudo apt-get install isc-dhcp-server tftpd-hpa syslinux pxelinux initramfs-tools","title":"Install requirements"},{"location":"Ubuntu%20thin%20client/#setup-dhcp-server-etcdhcpdhcpdconf","text":"allow booting; allow bootp; subnet 192.168.2.0 netmask 255.255.255.0 { range 192.168.2.xxx 192.168.2.xxx; option broadcast-address 192.168.2.255; option routers 192.168.2.xxx; option domain-name-servers 192.168.2.xxx; filename \"pxelinux.0\"; next-server 192.168.3.10; } # force the client to this ip for pxe. # This is only necessary assuming you want to send different images to different computers. host pxe_client { hardware ethernet xx:xx:xx:xx:xx:xx; fixed-address 192.168.2.xxx; }","title":"Setup dhcp server /etc/dhcp/dhcpd.conf"},{"location":"Ubuntu%20thin%20client/#set-dhcp-server-interface-must-be-in-the-correct-dhcp-range","text":"#/etc/default/isc-dhcp-server INTERFACESv4=ens18","title":"Set DHCP server interface (must be in the correct dhcp range)"},{"location":"Ubuntu%20thin%20client/#restart-dhcp-server-using-the-command","text":"sudo service isc-dhcp-server restart","title":"Restart DHCP Server using the command"},{"location":"Ubuntu%20thin%20client/#on-mine-i-had-vyos-point-to-my-tftp-server-and-nfsroot","text":"configure set service dhcp-server shared-network-name 'vxlan' subnet 192.168.205.0/24 option bootfile-name pxelinux.0 set service dhcp-server shared-network-name 'vxlan' subnet 192.168.205.0/24 option bootfile-server 192.168.205.10 commit save","title":"On mine I had vyos point to my tftp server and nfsroot"},{"location":"Ubuntu%20thin%20client/#configure-tftpd","text":"# /etc/default/tftpd-hpa RUN_DAEMON=\"yes\" TFTP_ADDRESS=\"0.0.0.0:69\" TFTP_USERNAME=\"tftp\" TFTP_DIRECTORY=\"/tftpboot\" TFTP_OPTIONS=\"-l -s\"","title":"Configure tftpd"},{"location":"Ubuntu%20thin%20client/#copy-files-from-server-may-also-work-with-client-fresh-install","text":"sudo mkdir -p /tftpboot/pxelinux.cfg sudo mkdir -p /tftpboot/boot sudo cp /usr/lib/PXELINUX/pxelinux.0 /tftpboot sudo cp -r /usr/lib/syslinux/modules/bios /tftpboot/boot/isolinux","title":"Copy files from server (may also work with client fresh install)"},{"location":"Ubuntu%20thin%20client/#create-tftpbootpxelinuxcfgdefault","text":"LABEL linux DEFAULT linux KERNEL vmlinuz-5.4.0-195-generic APPEND root=/dev/nfs initrd=initrd.img-5.4.0-195-generic nfsroot=192.168.205.10:/nfsroot ip=dhcp rw console=tty0 console=ttyS0,115200n8 Get tftp started sudo chmod -R 777 /tftpboot sudo /etc/init.d/tftpd-hpa start","title":"Create /tftpboot/pxelinux.cfg/default"},{"location":"Ubuntu%20thin%20client/#put-it-all-together","text":"","title":"Put it all together"},{"location":"Ubuntu%20thin%20client/#add-kernel-and-initrd-to-tftpboot-folder-from-the-fresh-install-copied-to-nfsroot","text":"sudo cp /nfsroot/home/ubuntu/vmlinuz-5.4.0-195-generic /tftpboot/ sudo cp /nfsroot/home/ubuntu/initrd.img-5.4.0-195-generic /tftpboot/","title":"Add kernel and initrd to tftpboot folder from the fresh install copied to nfsroot"},{"location":"Ubuntu%20thin%20client/#configure-nfsrootetcfstab-this-is-important-to-avoid-parallel-clients-locking-each-other-out","text":"none /var/run tmpfs defaults 0 0 none /var/log tmpfs defaults 0 0 none /var/lock tmpfs defaults 0 0 none /var/tmp tmpfs defaults 0 0 proc /proc proc defaults 0 0 none /media tmpfs defaults 0 0 none /var/lib/dhcp tmpfs defaults 0 0 none /tmp tmpfs defaults 0 0","title":"Configure /nfsroot/etc/fstab, this is important to avoid parallel clients locking each other out"},{"location":"Ubuntu%20thin%20client/#comment-out-exec-update-grub-in-nfsrootetckernelpostinstdzz-update-grub","text":"","title":"Comment out exec update-grub in /nfsroot/etc/kernel/postinst.d/zz-update-grub"},{"location":"Ubuntu%20thin%20client/#clear-out-entries-from-client-netplan-to-avoid-messing-with-interface-it-already-has-dhcp-setup","text":"may have to disable ipv6 if issues bringing up iface","title":"Clear out entries from client netplan to avoid messing with interface, it already has dhcp setup"},{"location":"Wireguard/","text":"NETNS_NAME=container WG_IFACE_NAME=wg0 CMD=\"curl ifconfig.me \" from proton wireguard config WG_ADDR=10.2.0.2/32 save privkey from config to file WG_PRIV_KEY=/home/justin/proton-wg/privkey-1 WG_ENDPOINT=103.125.235.18:51820 WG_PEER=agoivyLoPqor8MxA/s6UWJSMcA2pMl+ajO3vy/q3oWQ= sudo ip netns add {NETNS_NAME} sudo ip link add {WG_IFACE_NAME} type wireguard sudo ip link set {WG_IFACE_NAME} netns {NETNS_NAME} sudo ip -n {NETNS_NAME} addr add {WG_ADDR} dev {WG_IFACE_NAME} sudo ip netns exec {NETNS_NAME} wg set {WG_IFACE_NAME} private-key {WG_PRIV_KEY} peer {WG_PEER} allowed-ips 0.0.0.0/0 endpoint {WG_ENDPOINT} sudo ip -n {NETNS_NAME} link set {WG_IFACE_NAME} up sudo ip -n {NETNS_NAME} route add default dev {WG_IFACE_NAME sudo ip netns exec {NETNS_NAME} {CMD} example sudo ip netns add container sudo ip link add wg0 type wireguard sudo ip link set wg0 netns container sudo ip -n container addr add 10.2.0.2/32 dev wg0 sudo ip netns exec container wg set wg0 private-key /home/justin/proton-wg/privkey-1 peer agoivyLoPqor8MxA/s6UWJSMcA2pMl+ajO3vy/q3oWQ= allowed-ips 0.0.0.0/ 0 endpoint 103.125.235.18:51820 sudo ip -n container link set wg0 up sudo ip -n container route add default dev wg0 sudo ip netns exec container curl ifconfig.me","title":"Wireguard"},{"location":"Wireguard/#from-proton-wireguard-config","text":"WG_ADDR=10.2.0.2/32","title":"from proton wireguard config"},{"location":"Wireguard/#save-privkey-from-config-to-file","text":"WG_PRIV_KEY=/home/justin/proton-wg/privkey-1 WG_ENDPOINT=103.125.235.18:51820 WG_PEER=agoivyLoPqor8MxA/s6UWJSMcA2pMl+ajO3vy/q3oWQ= sudo ip netns add {NETNS_NAME} sudo ip link add {WG_IFACE_NAME} type wireguard sudo ip link set {WG_IFACE_NAME} netns {NETNS_NAME} sudo ip -n {NETNS_NAME} addr add {WG_ADDR} dev {WG_IFACE_NAME} sudo ip netns exec {NETNS_NAME} wg set {WG_IFACE_NAME} private-key {WG_PRIV_KEY} peer {WG_PEER} allowed-ips 0.0.0.0/0 endpoint {WG_ENDPOINT} sudo ip -n {NETNS_NAME} link set {WG_IFACE_NAME} up sudo ip -n {NETNS_NAME} route add default dev {WG_IFACE_NAME sudo ip netns exec {NETNS_NAME} {CMD}","title":"save privkey from config to file"},{"location":"Wireguard/#example","text":"sudo ip netns add container sudo ip link add wg0 type wireguard sudo ip link set wg0 netns container sudo ip -n container addr add 10.2.0.2/32 dev wg0 sudo ip netns exec container wg set wg0 private-key /home/justin/proton-wg/privkey-1 peer agoivyLoPqor8MxA/s6UWJSMcA2pMl+ajO3vy/q3oWQ= allowed-ips 0.0.0.0/ 0 endpoint 103.125.235.18:51820 sudo ip -n container link set wg0 up sudo ip -n container route add default dev wg0 sudo ip netns exec container curl ifconfig.me","title":"example"},{"location":"publications/","text":"Publication List Spatial-Temporal Graph Representation Learning for Tactical Networks Future State Prediction Water Pump Operation Optimization under Dynamic Market and Consumer Behaviour A Framework for Generating Attack Samples in Power Energy System using VAEs Vulnerability Assessment of False Data Injection Attacks on Optimal Power Flow Time Delay Attack Detection Using Recurrent Variational Autoencoder and K-means Clustering Defense against Power System Time Delay Attacks via Attention-based Multivariate Deep Learning","title":"Publications"},{"location":"publications/#publication-list","text":"Spatial-Temporal Graph Representation Learning for Tactical Networks Future State Prediction Water Pump Operation Optimization under Dynamic Market and Consumer Behaviour A Framework for Generating Attack Samples in Power Energy System using VAEs Vulnerability Assessment of False Data Injection Attacks on Optimal Power Flow Time Delay Attack Detection Using Recurrent Variational Autoencoder and K-means Clustering Defense against Power System Time Delay Attacks via Attention-based Multivariate Deep Learning","title":"Publication List"}]}